module tweednacl.keys;

import tweednacl.basics : safeRandomBytes;
import tweednacl.nacl : primitiveName;

enum KeyRole { Shared = 0, Public = 1, Secret = 2 }

/**
Gets thrown when a signature mismatches during the opening
a signed message or box.
*/
class KeyError : Exception
{
  this(string msg) { super(msg); }
}


/** Implements generic saving and loading routines for keys with validations. */
struct Key(Impl, size_t bytes, KeyRole role)
{
  import std.base64;
  import std.array;

  alias Primitive = Impl;
  alias T = ubyte[bytes];
  alias Bytes = bytes;

  enum Role = role;


  /** The raw bytes of the key. */
  T data;

  /**
    Randomizes the key data. Depending on the primitive this may or may not be
    a valid key.
   */
  void randomize(alias safeRnd=safeRandomBytes)()
  {
    safeRnd( data, Bytes );
  }

  /** Converts this keys raw data to its base64 representation */
  string toBase64()
  {
    return Base64.encode(data[]);
  }

  /**
  Replaces the data of this key with the data decoded from $(D base64Str)
  Returns: true if the data is valid and has been loaded, false otherwise.
  */
  bool loadBase64( string base64Str )
  {
    return decodeBase64( data[], base64Str );
  }

  /**
  Creates a new key from the given key string if it represents a
  valid key for the role and implementation of this key or
  throws a KeyError otherwise.

  Params: k = The key string generated by $(D keyString())
  Throws: KeyError if the key is invalid.
  */
  static auto fromBase64( string k )
  {
    mixin(genFromFormat("loadBase64"));
  }

  /**
    Creates a string of the implementation name, the key type
    and the key data, to make this key recognizable and loadable
    using loadKeyString(), and adds an MD5 checksum to the end.
    */
  string keyString()
  {
    return encodeKeyString( primitiveName!Impl, Role, data[] );
  }

  bool loadKeyString( string k )
  {
    return decodeKeyString( data[], primitiveName!Impl, Role, k );
  }

  /**
    Creates a new key from the given key string if it represents a
    valid key for the role and implementation of this key or
    throws a KeyError otherwise.

    Params: k = The key string generated by $(D keyString())
    Throws: KeyError if the key is invalid.
  */
  static auto fromKeyString( string k )
  {
    mixin(genFromFormat("loadKeyString"));
  }

  /**
    Creates a package of the implementation name, the key type
    and the key data, to make this key recognizable and loadable
    using loadKey().
    */
  ubyte[] keyData()
  {
    return encodeKeyData( primitiveName!Impl, Role, data );
  }


  bool loadKeyData( ubyte[] keyData)
  {
    return decodeKeyData( data[], primitiveName!Impl, Role, keyData );
  }


  static auto fromKeyData( ubyte[] k )
  {
    mixin(genFromFormat("loadKeyData"));
  }

}


private string genFromFormat( string converterName )
{
  import std.string;
  return format(q"{
    Key!(Impl,bytes,role) key;
    auto success = key.%s( k );
    if (!success) throw new KeyError("Invalid key input for %s.");
    return key;
  }", converterName, converterName);
}



/** Shortcuts for their representative key types */
alias sharedKey(Impl) = Key!(Impl, Impl.Key.length, KeyRole.Shared);
/** ditto */
alias publicKey(Impl) = Key!(Impl, Impl.PublicKey.length, KeyRole.Public);
/** ditto */
alias secretKey(Impl) = Key!(Impl, Impl.SecretKey.length, KeyRole.Secret);




private:


import std.string;
import std.array;
import std.base64;
import std.digest.crc;


alias checksumFn = crc32Of;
enum checksumLen = typeof(checksumFn([])).sizeof;
enum useCompression = false;

// By extracting these base functions the generated code from the possibly many
// key types is minimized.

pure bool decodeBase64(size_t MaxKeySize=1024)(ubyte[] keyOut, string s )
{
  immutable keySize = keyOut.length;
  immutable decodedBytes = Base64.encodeLength(keySize);
  if (decodedBytes != s.length) return false;

  ubyte[MaxKeySize] decodeBuf;
  Base64.decode(s, decodeBuf[]);
  keyOut[] = decodeBuf[0..keySize];
  return true;
}


ubyte[] encodeKeyData( string implId, KeyRole role, const ubyte[] keyData )
{
  immutable keySize = keyData.length;
  auto o = appender!(ubyte[]);
  o ~= cast(ubyte)implId.length;
  o ~= cast(ubyte)role;
  o ~= cast(ubyte)(keySize >> 8);
  o ~= cast(ubyte)keySize;

  o ~= checksumFn( implId )[];
  o ~= keyData;
  o ~= checksumFn(keyData)[];

  return o.data;
}


bool decodeKeyData( ubyte[] o, string implId, KeyRole role, const ubyte[] keyData )
{
  import std.zlib;
  enum headerSize = 4;

  immutable keySize = o.length;
  immutable keyStart = checksumLen + headerSize;
  immutable keyEnd = keyStart + keySize;

  if ((keyData.length != keySize + checksumLen + headerSize + checksumLen)
      || (keyData[0] != implId.length)
      || (keyData[1] != cast(ubyte)(role))
      || (keyData[headerSize..keyStart] != checksumFn(implId)))
    return false;

  immutable embededKeySize = ((cast(size_t)keyData[2]) << 8)
    + (cast(size_t)keyData[3]);
  if (embededKeySize != keySize) return false;

  const checksum = keyData[keyEnd..keyEnd+checksumLen];
  immutable expectedChecksum = checksumFn(keyData[keyStart..keyEnd]);

  if (expectedChecksum != checksum) return false; 
  o[] = keyData[keyStart..keyEnd];

  return true;
}


string encodeKeyString( string implId, KeyRole role, const ubyte[] data )
{
  return Base64.encode( encodeKeyData( implId, role, data ) );
}


bool decodeKeyString( ubyte[] o, string implId, KeyRole role, string k )
{
  return decodeKeyData( o, implId, role, Base64.decode(k) );
}


unittest
{
  import std.stdio;
  struct XSalsa20 {
    enum Primitive = "xsalsa20";
    enum Implementation = "crypto_stream/xsalsa20/tweet";
    enum Version = "-";

    alias Key = ubyte[32];
  }

  struct Curve25519XSalsa20Poly1305 {
    enum Primitive = "curve25519xsalsa20poly1305";
    enum Implementation = "crypto_stream/xsalsa20/tweet";

    alias PublicKey = ubyte[32];
    alias SecretKey = ubyte[32];
  }

  struct Ed25519
  {
    enum Primitive = "ed25519";
    enum Implementation = "crypto_sign/ed25519/tweet";


    alias PublicKey = ubyte[32];
    alias SecretKey = ubyte[64];
  }


  alias XSKey = sharedKey!XSalsa20;
  alias PKey = publicKey!Ed25519;
  alias SKey = secretKey!Ed25519;


  static void testKey(K)() {
    foreach(i;0..16)
    {
      auto k1 = K();
      auto kother = K();
      kother.randomize();
      k1.randomize();
      //writefln( "raw  = %s", k1.toBase64() );
      //writefln( "kstr = %s", k1.keyString() );
      //writefln( "key  = %s\n", k1.keyData() );

      assert( K.fromBase64( k1.toBase64() ).data == k1.data);
      K k2;
      assert( k2.loadBase64( k1.toBase64() ) );
      assert( k2.data == k1.data );

      assert( K.fromKeyData( k1.keyData() ).data == k1.data);
      K k3;
      assert( k3.loadKeyData( k1.keyData() ));
      assert( k3.data == k1.data );

      assert( K.fromKeyString( k1.keyString() ).data == k1.data);
      K k4;
      assert( k4.loadKeyString( k1.keyString() ));
      assert( k4.data == k1.data );


    }
  }

  testKey!XSKey();
  testKey!PKey();
  testKey!SKey();
  testKey!(publicKey!Curve25519XSalsa20Poly1305)();


  PKey pk;
  pk.randomize();

  import std.exception;

  // Public and private keys differ
  assertThrown!KeyError( SKey.fromKeyString( pk.keyString() ) );
  assertThrown!KeyError( SKey.fromKeyData( pk.keyData() ) );
  assertThrown!KeyError( SKey.fromBase64( pk.toBase64() ) );

  // These keys are the same size, but have different primitives
  assertThrown!KeyError( XSKey.fromKeyString( pk.keyString() ));
  assertThrown!KeyError( XSKey.fromKeyData( pk.keyData() ));
  // since both keys are the same size, Base64 does not see the error
  // by design
  assertNotThrown!KeyError( XSKey.fromBase64( pk.toBase64() ));

  alias Pk2 = publicKey!Curve25519XSalsa20Poly1305;
  alias Sk2 = secretKey!Curve25519XSalsa20Poly1305;

  Pk2 pk_2;
  Sk2 sk_2;

  pk_2.randomize();

  // These keys are the same size, but have different primitives
  assertThrown!KeyError( Sk2.fromKeyString( pk_2.keyString() ));
  assertThrown!KeyError( Sk2.fromKeyData( pk_2.keyData() ));
  // since both keys are the same size, Base64 does not see the error
  // by design
  assertNotThrown!KeyError( Sk2.fromBase64( pk_2.toBase64() ));

}

