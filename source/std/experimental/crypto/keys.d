module std.experimental.crypto.keys;

import tweednacl.random : safeRandomBytes;
import std.experimental.crypto.nacl : primitiveName;

enum KeyRole { Shared = 0, Public = 1, Secret = 2 }

/**
Gets thrown when a signature mismatches during the opening
a signed message or box.
*/
class KeyError : Exception
{
  this(string msg) { super(msg); }
}


/** Implements generic saving and loading routines for keys with validations. */
template Key(Impl, size_t bytes, KeyRole role)
{

  // code generator
  private string genFromFormat( string converterName )
  {
    import std.string;
    return format(q"{
        Key!(Impl,bytes,role) key;
        auto success = key.%s( k );
        if (!success) throw new KeyError("Invalid key input for %s.");
        return key;
      }", converterName, converterName);
  }

  struct Key
  {
    import std.base64;
    import std.array;

    alias Primitive = Impl;
    alias T = ubyte[bytes];
    alias Bytes = bytes;

    enum Role = role;


    /** The raw bytes of the key. */
    T data;

    /**
      Creates a string of the implementation name, the key type
      and the key data, to make this key recognizable and loadable
      using loadKeyString(), and adds an MD5 checksum to the end.
      */
    @property string keyString()
    {
      return encodeKeyString( primitiveName!Impl, Role, data[] );
    }

    bool loadKeyString( string k )
    {
      return decodeKeyString( data[], primitiveName!Impl, Role, k );
    }

    /**
      Creates a new key from the given key string if it represents a
      valid key for the role and implementation of this key or
      throws a KeyError otherwise.

      Params: k = The key string generated by $(D keyString())
      Throws: KeyError if the key is invalid.

      Examples:
      ---
      alias PKey = publicKey!Ed25519;
      PKey k;
      k.randomize();
      assert( PKey.fromKeyString( k.keyString() ) == k);
      ---
    */
    static auto fromKeyString( string k )
    {
      mixin(genFromFormat("loadKeyString"));
    }

    /**
      Creates a package of the implementation name, the key type
      and the key data, to make this key recognizable and loadable
      using loadKey().
      */
    @property ubyte[] keyData()
    {
      return encodeKeyData( primitiveName!Impl, Role, data );
    }


    bool loadKeyData( ubyte[] keyData)
    {
      return decodeKeyData( data[], primitiveName!Impl, Role, keyData );
    }

    /**
    Creates a new key from the given key data if it represents a
    valid key for the role and implementation of this key or
    throws a KeyError otherwise.

    Params: k = The key string generated by $(D keyData())
    Throws: KeyError if the key is invalid.

    Examples:
    ---
    alias PKey = publicKey!Ed25519;
    PKey _k;
    _k.randomize();
    assert( PKey.fromKeyString( _k.keyString() ).data == _k.data);
    ---
    */
    static auto fromKeyData( ubyte[] k )
    {
      mixin(genFromFormat("loadKeyData"));
    }



    /**
    Randomizes the key data. Depending on the primitive this may or may not be
    a valid key.
    */
    void randomize(alias safeRnd=safeRandomBytes)()
    {
      safeRnd( data, Bytes );
    }

    /** Converts this keys raw data to its base64 representation */
    string toBase64()
    {
      return Base64.encode(data[]);
    }

    /**
    Replaces the data of this key with the data decoded from $(D base64Str)
    Returns: true if the data is valid and has been loaded, false otherwise.
    */
    bool loadBase64( string base64Str )
    {
      return decodeBase64( data[], base64Str );
    }

    /**
    Creates a new key from the given key string if it represents a
    valid key for the role and implementation of this key or
    throws a KeyError otherwise.

    Params: k = The key string generated by $(D keyString())
    Throws: KeyError if the key is invalid.
    */
    static auto fromBase64( string k )
    {
      mixin(genFromFormat("loadBase64"));
    }
  }

}




/** Shortcuts for their representative key types 

Examples:
---
alias XSKey = sharedKeyT!XSalsa20;
alias PKey = publicKeyT!Ed25519;
alias SKey = secretKeyT!Ed25519;
---
*/
alias sharedKeyT(Impl) = Key!(Impl, Impl.Key.length, KeyRole.Shared);
/** ditto */
alias publicKeyT(Impl) = Key!(Impl, Impl.PublicKey.length, KeyRole.Public);
/** ditto */
alias secretKeyT(Impl) = Key!(Impl, Impl.SecretKey.length, KeyRole.Secret);



/**

A generic pair of secret and public keys for a primitive.

*/
struct KeyPair(Impl)
{
  /** Accessor for the implementation */
  alias Primitive = Impl;

  /** The memory representation of a public key */
  alias PublicKey = Impl.PublicKey;

  /** The memory representation of a secret key */
  alias SecretKey = Impl.SecretKey;

  /** The public key to encode / validate signed data with. */
  PublicKey publicKey;

  /** The secret key to decode / sign data with. */
  SecretKey secretKey;

  ~this() { erase(); }

  /** Overwrite the keys with zeroes ( automatically gets called on destruction ).  */
  void erase() { publicKey[] = 0; secretKey[] = 0; }

  @property {
    /**
      Gets a key handler object for the keys.

      Examples:
      ---
      auto k = generateSignKeyPair();
      wirtefln("Public key: %s", k.pub.toKeyString());
      wirtefln("Secret key: %s", k.sec.toKeyString());
      ---
    */
    auto ref pub() { return cast(publicKeyT!Impl*)(&publicKey[0]); }
    /** ditto */
    auto ref sec() { return cast(secretKeyT!Impl*)(&secretKey[0]); }
  }
}


/**
Generates a pair of public and private keys for an implementation.

Params:
Impl = The implementation to use (defaults to Ed25519)
*/
auto generateKeypair(Impl, alias safeRnd=safeRandomBytes)()
{
  auto o = KeyPair!Impl();
  Impl.keypair!safeRnd( o.publicKey, o.secretKey );
  return o;
}

/**
Generates a secret key.
*/
auto generateSecretKey(Impl, alias safeRnd=safeRandomBytes)()
{
  Impl.Key k;
  safeRnd( k, Impl.Key.length );
  return k;
}


private:


import std.string;
import std.array;
import std.base64;
import std.digest.crc;


alias checksumFn = crc32Of;
enum checksumLen = typeof(checksumFn([])).sizeof;
enum useCompression = false;

// By extracting these base functions the generated code from the possibly many
// key types is minimized.

pure bool decodeBase64(size_t MaxKeySize=1024)(ubyte[] keyOut, string s )
{
  immutable keySize = keyOut.length;
  immutable decodedBytes = Base64.encodeLength(keySize);
  if (decodedBytes != s.length) return false;

  ubyte[MaxKeySize] decodeBuf;
  Base64.decode(s, decodeBuf[]);
  keyOut[] = decodeBuf[0..keySize];
  return true;
}


ubyte[] encodeKeyData( string implId, KeyRole role, const ubyte[] keyData )
{
  immutable keySize = keyData.length;
  auto o = appender!(ubyte[]);
  o ~= cast(ubyte)implId.length;
  o ~= cast(ubyte)role;
  o ~= cast(ubyte)(keySize >> 8);
  o ~= cast(ubyte)keySize;

  o ~= checksumFn( implId )[];
  o ~= keyData;
  o ~= checksumFn(keyData)[];

  return o.data;
}


bool decodeKeyData( ubyte[] o, string implId, KeyRole role, const ubyte[] keyData )
{
  enum headerSize = 4;

  immutable keySize = o.length;
  immutable keyStart = checksumLen + headerSize;
  immutable keyEnd = keyStart + keySize;
  immutable encodedTargetLen = keySize + 2 * checksumLen + headerSize;

  if ((keyData.length != encodedTargetLen)
      || (keyData[0] != implId.length)
      || (keyData[1] != cast(ubyte)(role))
      || (keyData[headerSize..keyStart] != checksumFn(implId)))
    return false;

  immutable embededKeySize = ((cast(size_t)keyData[2]) << 8)
    + (cast(size_t)keyData[3]);
  if (embededKeySize != keySize) return false;

  const checksum = keyData[keyEnd..keyEnd+checksumLen];
  immutable expectedChecksum = checksumFn(keyData[keyStart..keyEnd]);

  if (expectedChecksum != checksum) return false; 
  o[] = keyData[keyStart..keyEnd];

  return true;
}


string encodeKeyString( string implId, KeyRole role, const ubyte[] data )
{
  return Base64.encode( encodeKeyData( implId, role, data ) );
}


bool decodeKeyString( ubyte[] o, string implId, KeyRole role, string k )
{
  return decodeKeyData( o, implId, role, Base64.decode(k) );
}


unittest
{
  import std.stdio;
  struct XSalsa20 {
    enum Primitive = "xsalsa20";
    enum Implementation = "crypto_stream/xsalsa20/tweet";
    enum Version = "-";

    alias Key = ubyte[32];
  }

  struct Curve25519XSalsa20Poly1305 {
    enum Primitive = "curve25519xsalsa20poly1305";
    enum Implementation = "crypto_stream/xsalsa20/tweet";

    alias PublicKey = ubyte[32];
    alias SecretKey = ubyte[32];
  }

  struct Ed25519
  {
    enum Primitive = "ed25519";
    enum Implementation = "crypto_sign/ed25519/tweet";


    alias PublicKey = ubyte[32];
    alias SecretKey = ubyte[64];
  }


  alias XSKey = sharedKeyT!XSalsa20;
  alias PKey = publicKeyT!Ed25519;
  alias SKey = secretKeyT!Ed25519;


  static void testKey(K)() {
    foreach(i;0..16)
    {
      auto k1 = K();
      auto kother = K();
      kother.randomize();
      k1.randomize();

      assert( K.fromBase64( k1.toBase64() ).data == k1.data);
      K k2;
      assert( k2.loadBase64( k1.toBase64() ) );
      assert( k2.data == k1.data );

      assert( K.fromKeyData( k1.keyData ).data == k1.data);
      K k3;
      assert( k3.loadKeyData( k1.keyData ));
      assert( k3.data == k1.data );

      assert( K.fromKeyString( k1.keyString ).data == k1.data);
      K k4;
      assert( k4.loadKeyString( k1.keyString ));
      assert( k4.data == k1.data );


    }
  }

  testKey!XSKey();
  testKey!PKey();
  testKey!SKey();
  testKey!(publicKeyT!Curve25519XSalsa20Poly1305)();


  PKey pk;
  pk.randomize();

  import std.exception;

  // Public and private keys differ
  assertThrown!KeyError( SKey.fromKeyString( pk.keyString() ) );
  assertThrown!KeyError( SKey.fromKeyData( pk.keyData() ) );
  assertThrown!KeyError( SKey.fromBase64( pk.toBase64() ) );

  // These keys are the same size, but have different primitives
  assertThrown!KeyError( XSKey.fromKeyString( pk.keyString() ));
  assertThrown!KeyError( XSKey.fromKeyData( pk.keyData() ));
  // since both keys are the same size, Base64 does not see the error
  // by design
  assertNotThrown!KeyError( XSKey.fromBase64( pk.toBase64() ));

  alias Pk2 = publicKeyT!Curve25519XSalsa20Poly1305;
  alias Sk2 = secretKeyT!Curve25519XSalsa20Poly1305;

  Pk2 pk_2;
  Sk2 sk_2;

  pk_2.randomize();

  // These keys are the same size, but have different primitives
  assertThrown!KeyError( Sk2.fromKeyString( pk_2.keyString() ));
  assertThrown!KeyError( Sk2.fromKeyData( pk_2.keyData() ));
  // since both keys are the same size, Base64 does not see the error
  // by design
  assertNotThrown!KeyError( Sk2.fromBase64( pk_2.toBase64() ));

}

